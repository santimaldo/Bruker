# -*- coding: utf-8 -*-
"""
Created on Thu Sep 15 12:10:32 2022


@author: Santi

"""

import nmrglue as ng
import matplotlib.pyplot as plt
import numpy as np
from Datos import *
from Autophase import autophase
import scipy.integrate as integrate
import re

################## Functions ###########################

def read_bsms_field(path_archivo):
    """
    Lee un archivo con formato específico y devuelve el array 'x' como lista de floats.

    Parámetros:
    path_archivo (str): Ruta al archivo de entrada.

    Retorna:
    list[float]: Lista con los valores del array x.
    """
    with open(path_archivo+'Klog_opt', 'r') as f:
        for linea in f:
            if linea.startswith("x="):
                contenido = linea.strip().split("=", 1)[1]
                x = eval(contenido)
                return x
    raise ValueError("No se encontro una linea que empiece con 'x='.")


def integrate_around_peak(ppmAxis, spectrum, window_width):
    """
    Integra un espectro en un rango centrado en el máximo dentro del ancho especificado.

    Parámetros:
    - ppmAxis (np.array): eje de ppm (decreciente, tipo Bruker)
    - spectrum (np.array): espectro real correspondiente
    - window_width (float): ancho de integración en ppm

    Retorna:
    - float: valor de la integral en el rango centrado en el máximo
    """
    max_index = np.argmax(np.abs(spectrum))
    center_ppm = ppmAxis[max_index]

    r1 = center_ppm - window_width / 2
    r2 = center_ppm + window_width / 2

    # Adaptar a orden decreciente del eje ppm
    lower, upper = sorted([r1, r2], reverse=True)
    mask = (ppmAxis <= lower) & (ppmAxis >= upper)

    return -integrate.simpson(spectrum[mask], x=ppmAxis[mask])


#%%                
    return np.array(data)
################## end Functions #######################



# directorio de datos
expns = [28, 29]
# expns = [71]
absolute = False
autoph = True 
path  =rf"C:\Users\Santi\OneDrive - University of Cambridge\NMRdata\400dnp\InSitu_May_2025/"
# directorio de guradado
savepath= r"C:\Users\Santi\OneDrive - University of Cambridge\Projects\LiMetal\Bruker/analysis/2025-05_mesh/spec1d_MeshAndLFP/"
muestra = ""
save = False
plotRange = [200,-300]
# rango de integracion
ppmRanges = [[200,-300]
            #[300, 150],
            #[-0.5, -9]            
            ]
window_width = 50  # ancho de cada ventana desde el mínimo local


#=====================================================================
# 2D experiments
#=====================================================================
fig_spec, ax_spec = plt.subplots(num=17856)
fig_popt, ax_popt = plt.subplots(num=382910)

for expn in expns:
    Signals = np.array([])

    # grafico todos los espectros juntos
    path_2D = f"{path}/{expn}/"
    datos = DatosProcesados2D(f'{path}/{expn}/',
                                read_pp = False)
    datos.espectro.ppmSelect(plotRange)
    ppmAxis = datos.espectro.ppmAxis
    spec = datos.espectro.real
    speci = datos.espectro.imag



    # Plot the 1D spectra
    for kk in range(spec.shape[0]):
        ####ax_spec.plot(ppmAxis,spec[kk,:])
        # spec1d, speci1d, ang = autophase(ppmAxis,
        #                         spec[kk,:],
        #                         speci[kk,:],
        #                         precision=1)
        # print(ang)
        # spec[kk,:]  = spec1d
        # speci[kk,:] = speci1d
        # ax_spec.plot(ppmAxis, spec1d)
        # ax_spec.plot(ppmAxis, speci1d, '--')
        spec1d = spec[kk,:]
        speci1d = speci[kk,:]
        if absolute:
            abs_spec = np.abs(spec1d + 1j*speci1d)
            spec[kk,:]  = abs_spec
            spec1d = abs_spec
        elif autoph:
            spec1d = ng.proc_autophase.autops(spec1d+1j*speci1d, "acme") 
            spec[kk,:]  = ng.process.proc_bl.cbf(spec1d.real, last=100)
        ax_spec.plot(ppmAxis, spec1d)

        


    bsms_field = read_bsms_field(path_2D)


    ###### start integrating the spectra
    colors = ['k', 'b', 'r', 'forestgreen', 'cyan', 'magenta']
    ii = -1
    for ppmRange in ppmRanges:
        ii += 1
        color = colors[ii]
        ax_spec.set_xlim(np.max(ppmAxis), np.min(ppmAxis))
        r1, r2 = [np.min(ppmRange), np.max(ppmRange)]  # redefino el rango
        ax_spec.axvspan(r1, r2, alpha=0.15, color=color)
        ax_spec.axhline(0, color='k')

        # signal = datos.Integrar(ppmRange=ppmRange)
        signal = np.zeros(spec.shape[0])
        for kk in range(spec.shape[0]):
            signal[kk] = integrate_around_peak(ppmAxis, spec[kk, :], window_width)
        #tau_fit, signal_fit, residuals = datos.T1fit()
        Signals = np.append(Signals, signal)


    Signals = Signals[Signals != 0] # remove zeros generated by stopping the experiment
    if expn == expns[0]:
        all_Signals = Signals
        all_bsms_field = bsms_field
    else:
        all_Signals = np.concatenate((all_Signals, Signals))
        all_bsms_field = np.concatenate((all_bsms_field, bsms_field))

    if save:
        for kk in range(Signals.size):
            np.savetxt(f"{savepath}/{muestra}_bsms_{bsms_field[kk]}.dat",
                    np.array([ppmAxis, spec[kk,:]]).T,
                    header="ppmAxis\treal")
    ax_popt.plot(bsms_field, Signals, 'o')#, color=color, label="Rising Edge")

print(np.array([all_bsms_field, all_Signals]).T)
